#pragma once

#include "kaizermud/base.h"
#include <ctime>
#include <string>
#include <map>
#include <unordered_map>
#include <vector>
#include <memory>
#include <list>
#include <boost/json.hpp>
#include <optional>
#include <boost/system.hpp>
#include <boost/asio/error.hpp>
#include "kaizermud/thermite.h"

namespace kaizermud::net {

    enum class Protocol : uint8_t {
        Telnet = 0,
        WebSocket = 1
    };

    enum class ColorType : uint8_t {
        NoColor = 0,
        Standard = 1,
        Xterm256 = 2,
        TrueColor = 3
    };

    struct ProtocolCapabilities {
        Protocol protocol{Protocol::Telnet};
        bool encryption = false;
        std::string clientName = "UNKNOWN", clientVersion = "UNKNOWN";
        std::string encoding = "";
        bool utf8 = false;
        ColorType colorType = ColorType::NoColor;
        int width = 80, height = 52;
        bool gmcp = false, msdp = false, mssp = false, mxp = false;
        bool mccp2 = false, mccp2_active = false, mccp3 = false, mccp3_active = false;
        bool ttype = false, naws = true, sga = true, linemode = false;
        bool force_endline = false, oob = false, tls = false;
        bool screen_reader = false, mouse_tracking = false, vt100 = false;
        bool osc_color_palette = false, proxy = false, mnes = false;
        void deserialize(const boost::json::value &j);
    };

    class ClientConnection {
        // They need this PURELY for access to that darned spsc_channel.
        friend class kaizermud::thermite::Link;
        friend class kaizermud::thermite::LinkManager;
    public:
        ClientConnection(kaizermud::thermite::LinkManager &lm, uint64_t conn_id, spsc_channel<boost::json::value> chan)
        : lm(lm), connID(conn_id), fromLink(std::move(chan)) {}
        void sendText(const std::string &messg);
        //void sendMSSP(const std::vector<std::tuple<std::string, std::string>> &data);
        //void sendGMCP(const std::string &txt);
        void onWelcome();
        void onHeartbeat(boost::asio::steady_timer::duration deltaTime);
        void onNetworkDisconnected();
        [[nodiscard]] const ProtocolCapabilities& getCapabilities() const;
        [[nodiscard]] uint64_t getConnID() const;
        [[nodiscard]] std::optional<ObjectID> getAccountID() const;
    protected:
        uint64_t connID;

        // A Connection might or might not be logged in.
        std::optional<ObjectID> accountID;
        // Some time structs to handle when we received connections.
        // These probably need some updating on this and Thermite side...
        kaizermud::thermite::LinkManager &lm;
        time_t connected{};
        time_t last_activity{};
        time_t last_read{};

        // This is embedded for ease of segmentation but this struct isn't
        // actually used anywhere else.
        ProtocolCapabilities capabilities;

        // The connection ID is a unique identifier for this connection.
        // It is generated by Thermite. Thermite should never re-use IDs
        // so if we ever get sent a duplicate by Thermite, something is
        // terribly wrong.
        uint64_t conn_id{};

        // Later we'll need to handle more than just text commands. But this should handle
        std::list<std::string> pending_commands;

        spsc_channel<boost::json::value> fromLink;

    };


}